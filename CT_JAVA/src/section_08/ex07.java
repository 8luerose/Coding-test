package section_08;
import java.util.*;

public class ex07 {
    int[][] dy = new int[35][35];
    public int DFS(int N, int r) {
        if (dy[N][r] > 0) return (dy[N][r]);
        if (N == r || r == 0) return 1;
        else return dy[N][r] = DFS(N - 1, r - 1) + DFS(N - 1, r);
    }
    public static void main(String[] args) {
        ex07 T = new ex07();
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int r = sc.nextInt();
        System.out.println(T.DFS(N, r));
        sc.close();
    }
}

/** 입출력
▣ 입력
33 19
▣ 출력
818809200
*/

/** 배울점
1. 조합 공식 "nCr = (n-1)C(r-1) + (n-1)Cr"의 상세 이해
   - 이 공식은 조합(Combination)을 계산하는 재귀적 방법으로, 파스칼 삼각형에서 유래됨
   - 의미를 풀어서 설명:
     * n개의 물건에서 r개를 선택하는 경우의 수는:
       - n번째 물건을 선택하는 경우: (n-1)C(r-1)
         (n번째를 뽑았으니 r-1개를 n-1개에서 뽑음)
       - n번째 물건을 선택하지 않는 경우: (n-1)Cr
         (n번째를 안 뽑았으니 r개를 n-1개에서 뽑음)
   - 예시로 n=4, r=2를 단계별로 살펴보자:
     * 4C2 = 3C1 + 3C2
     * 3C1 = 2C0 + 2C1 = 1 + 2 = 3
     * 3C2 = 2C1 + 2C2 = 2 + 1 = 3
     * 그러므로 4C2 = 3 + 3 = 6
   - 실제로 4C2는 "4개 중 2개를 선택하는 경우의 수"로, {1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4} 총 6가지

2. 재귀 호출의 전체 흐름 (n=4, r=2 기준)
   - DFS(4,2) 호출 시 어떤 일이 일어나는지 단계별로:
     1) dy[4][2] = 0이므로 계산 시작
     2) DFS(3,1) + DFS(3,2)
        - DFS(3,1):
          * dy[3][1] = 0
          * DFS(2,0) + DFS(2,1)
          * DFS(2,0): r=0이므로 1 반환
          * DFS(2,1): dy[2][1] = 0 → DFS(1,0) + DFS(1,1)
            - DFS(1,0): r=0이므로 1
            - DFS(1,1): N==r이므로 1
            - dy[2][1] = 1 + 1 = 2
          * dy[3][1] = 1 + 2 = 3
        - DFS(3,2):
          * dy[3][2] = 0
          * DFS(2,1) + DFS(2,2)
          * DFS(2,1): dy[2][1] = 2 (이미 계산됨, 재사용)
          * DFS(2,2): N==r이므로 1
          * dy[3][2] = 2 + 1 = 3
     3) dy[4][2] = 3 + 3 = 6 저장 및 반환
   - 이 과정에서 모든 하위 호출을 추적 가능

3. 메모이제이션의 세부 동작
   - dy 배열은 35x35 크기의 2차원 배열로, 초기값은 모두 0
   - "if (dy[N][r] > 0) return dy[N][r]"로 이미 계산된 값 확인
   - 계산 후 "dy[N][r] = ..."로 저장
   - 예시(n=4, r=2)에서 dy 배열 변화:
     * 초기: 모두 0
     * DFS(1,0)=1 계산 후: dy[1][0] = 1
     * DFS(1,1)=1 계산 후: dy[1][1] = 1
     * DFS(2,1)=2 계산 후: dy[2][1] = 2
     * DFS(2,0)=1 계산 후: dy[2][0] = 1
     * DFS(3,1)=3 계산 후: dy[3][1] = 3
     * DFS(2,2)=1 계산 후: dy[2][2] = 1
     * DFS(3,2)=3 계산 후: dy[3][2] = 3
     * DFS(4,2)=6 계산 후: dy[4][2] = 6
   - 이후 동일 (N,r) 호출 시 저장된 값 바로 사용

4. 종료 조건의 역할
   - "if (N == r || r == 0) return 1"은 재귀의 기저 사례
   - 왜 1인가?
     * N==r: 모든 원소를 선택 → 1가지 경우
     * r==0: 아무것도 선택 안 함 → 1가지 경우
   - 예: DFS(2,0)=1, DFS(2,2)=1
*/

/* 해설
1. 전체적인 동작 원리 상세 설명
   - 이 프로그램은 조합 수를 재귀적으로 계산하며, 메모이제이션으로 효율성을 높임
   - 동작 순서:
     1) main에서 N, r 입력 받음 (예: 33, 19)
     2) DFS(33,19) 호출
     3) dy[33][19]가 0이므로 계산 시작
     4) 공식에 따라 DFS(32,18) + DFS(32,19) 호출
     5) 각 호출이 다시 재귀적으로 분해됨
     6) 기저 사례(N==r 또는 r==0)에 도달하면 1 반환
     7) 결과를 합산하며 dy 배열에 저장
     8) 최종 값 818809200 출력
   - 재귀 트리가 매우 크지만, 메모이제이션으로 중복 계산 제거

2. nCr 공식의 원리와 동작 예시 (n=5, r=3)
   - 공식: 5C3 = 4C2 + 4C3
   - 단계별 계산:
     * 4C2 = 3C1 + 3C2
       - 3C1 = 2C0 + 2C1 = 1 + 2 = 3
       - 3C2 = 2C1 + 2C2 = 2 + 1 = 3
       - 4C2 = 3 + 3 = 6
     * 4C3 = 3C2 + 3C3
       - 3C2 = 2C1 + 2C2 = 2 + 1 = 3
       - 3C3 = N==r이므로 1
       - 4C3 = 3 + 1 = 4
     * 5C3 = 6 + 4 = 10
   - 실제로 5C3 = 5!/(3!*2!) = 10 맞음
   - 이 과정이 재귀 호출로 구현됨

3. 메모이제이션 활용의 구체적 예시
   - n=5, r=3 계산 중:
     * DFS(3,2)가 여러 경로에서 호출됨
     * 첫 계산: DFS(3,2) = DFS(2,1) + DFS(2,2) = 2 + 1 = 3
     * dy[3][2] = 3 저장
     * 이후 DFS(3,2) 호출 시 dy[3][2]에서 3 즉시 반환
   - 메모이제이션 없으면:
     * DFS(3,2)를 매번 새로 계산 (2C1 + 2C2)
     * 하위 호출도 반복 → 지수 시간 복잡도
   - 메모이제이션 있으면:
     * 한 번 계산 후 재사용 → O(N*r) 시간 복잡도

4. 입력값(33,19)에 대한 상세 분석
   - 33C19는 매우 큰 수로, 직접 분해는 어렵지만 코드 동작 원리 동일
   - 재귀 트리:
     * DFS(33,19) = DFS(32,18) + DFS(32,19)
     * DFS(32,18) = DFS(31,17) + DFS(31,18)
     * ... 계속 분해
   - dy 배열이 점진적으로 채워지며:
     * dy[1][0] = 1부터 시작
     * dy[33][19] = 818809200까지 계산
   - 메모이제이션 덕분에 각 (N,r) 쌍이 한 번만 계산됨
*/