package section_08;
import java.util.*;

public class ex10 {
	static int[] dx = {-1, 0, 1, 0};
	static int[] dy = {0, 1, 0, -1};
	static int[][] arr;
	static int answer = 0;
	public void DFS(int x, int y) {
		if (x == 7 && y == 7) {
			answer++;
		}
		else {
			for (int i = 0; i < 4; i++) {
				int nx = x + dx[i];
				int ny = y + dy[i];
				if (nx >= 1 && nx <= 7 && ny >= 1 && ny <= 7 && arr[nx][ny] == 0) {
					arr[nx][ny] = 1;
					DFS(nx, ny);
					arr[nx][ny] = 0;
				}
			}
		}
	}
	public static void main(String[] args) {
		ex10 T = new ex10();
		Scanner sc = new Scanner(System.in);
		arr = new int[8][8];
		for (int i = 1; i <= 7; i++) {
			for (int j = 1; j <= 7; j++) {
				arr[i][j] = sc.nextInt();
			}
		}
		arr[1][1] = 1;
		T.DFS(1,1);
		System.out.println(answer);
		sc.close();
	}

}
/** 입출력
0 0 0 0 0 0 0
0 1 1 1 1 1 0
0 0 0 1 0 0 0
1 1 0 1 0 1 1
1 1 0 0 0 0 1
1 1 0 1 1 0 0
1 0 0 0 0 0 0
=>
8
*/

/** 배울점
1. 미로 탐색의 DFS 접근
   - 이 코드는 7x7 미로에서 (1,1)에서 (7,7)까지 가는 경로 수를 계산
   - DFS(깊이 우선 탐색)를 사용해 모든 가능한 경로 탐색
   - 기본 아이디어:
     * 현재 위치(x,y)에서 상하좌우로 이동하며 경로 탐색
     * 방문한 곳은 arr 배열에 1로 표시해 중복 방지
     * (7,7)에 도달하면 경로 수 증가

2. "dx, dy 배열과 nx, ny 계산"의 상세 동작
   - "static int[] dx = {-1, 0, 1, 0}"와 "static int[] dy = {0, 1, 0, -1}"는 방향 벡터
     * dx[0],dy[0] = (-1,0): 상
     * dx[1],dy[1] = (0,1): 우
     * dx[2],dy[2] = (1,0): 하
     * dx[3],dy[3] = (0,-1): 좌
   - "int nx = x + dx[i]; int ny = y + dy[i];"는 다음 이동 위치 계산
     * 예: (x,y)=(1,1)에서 i=1(우) → nx=1+0=1, ny=1+1=2 → (1,2)
   - 네 방향을 순차적으로 탐색하며 이동 가능 여부 확인

3. "arr[nx][ny] = 1; DFS(nx, ny); arr[nx][ny] = 0;"의 백트래킹 과정
   - 이동 가능 조건: "nx >= 1 && nx <= 7 && ny >= 1 && ny <= 7 && arr[nx][ny] == 0"
     * 격자 범위 내이고, 벽이 아니며(0), 방문하지 않음
   - 동작:
     * arr[nx][ny] = 1: 방문 표시
     * DFS(nx, ny): 해당 위치로 재귀 호출
     * arr[nx][ny] = 0: 탐색 후 원상복구(백트래킹)
   - 예: (1,1) → (1,2)
     * arr[1][2]=1로 방문 표시
     * DFS(1,2) 호출
     * 돌아오면 arr[1][2]=0으로 복구 → 다른 경로 탐색 가능

4. 재귀 호출 흐름 (입력 예시로 일부 추적)
   - DFS(1,1) 시작:
     * arr[1][1]=1로 이미 설정
     * 네 방향 탐색:
       - 상(-1,0): (0,1) → 범위 밖
       - 우(0,1): (1,2) → arr[1][2]=1 (벽), 불가
       - 하(1,0): (2,1) → arr[2][1]=0, 가능
       - 좌(0,-1): (1,0) → 범위 밖
     * DFS(2,1) 호출:
       - arr[2][1]=1
       - 상: (1,1) → 방문함
       - 우: (2,2) → arr[2][2]=0, 가능
       - 하: (3,1) → arr[3][1]=0, 가능
       - 좌: (2,0) → 범위 밖
   - 이 과정이 (7,7)까지 반복
*/

/* 해설
1. 전체적인 동작 원리 상세 설명
   - 이 프로그램은 7x7 미로에서 (1,1)에서 (7,7)까지의 경로 수를 DFS로 계산
   - 동작 과정:
     1) main에서 7x7 격자 입력 받음
     2) arr[1][1]=1로 시작점 방문 표시
     3) DFS(1,1) 호출로 탐색 시작
     4) 각 위치에서 네 방향 탐색하며 이동
     5) (7,7)에 도달하면 answer 증가
     6) 모든 경로 탐색 후 answer 출력
   - 백트래킹으로 방문 표시를 원상복구하며 모든 가능성 탐색

2. "dx, dy와 nx, ny"를 활용한 DFS 동작
   - 방향 벡터(dx, dy)는 상하좌우 이동을 정의
   - "int nx = x + dx[i]; int ny = y + dy[i];"로 다음 위치 계산
   - 예: (3,3)에서 네 방향:
     * 상: (2,3) = (3-1,3)
     * 우: (3,4) = (3,3+1)
     * 하: (4,3) = (3+1,3)
     * 좌: (3,2) = (3,3-1)
   - 조건 체크 후 이동 가능 시 DFS 재귀 호출

3. 백트래킹의 핵심 "arr[nx][ny] = 1; DFS(nx, ny); arr[nx][ny] = 0;"
   - 이 세 줄이 경로 탐색의 핵심:
     * 방문 표시(arr[nx][ny]=1): 중복 방지
     * 재귀 호출(DFS(nx,ny)): 다음 단계 탐색
     * 복구(arr[nx][ny]=0): 다른 경로를 위해 초기화
   - 예: (2,1) → (2,2):
     * arr[2][2]=1로 표시
     * DFS(2,2) 호출
     * 돌아와서 arr[2][2]=0으로 복구 → (3,1) 탐색 가능
   - 백트래킹으로 모든 경로를 누락 없이 탐색

4. 입력값에 대한 경로 탐색 분석
   - 입력 예시에서 (1,1) → (7,7) 경로 수 = 8
   - 초기 몇 단계:
     * (1,1) → (2,1) → (3,1) → (3,2) → (3,3) ...
   - (7,7)에 도달하는 경로는 8가지로:
     * 다양한 경로를 통해 answer=8 계산
   - 벽(1)과 방문 체크로 불가능한 경로 차단
*/