package section_08;
import java.util.*;

public class ex04 {
	static int N, M;
	static int[] arr;

	public void DFS(int L) {
		if (L == M) {
			for (int x : arr) System.out.print( x + " ");
			System.out.println();
		}
		else {
			for (int i = 1; i <= N; i++) {
				arr[L] = i;
				DFS(L + 1);
			}
		}
	}
	public static void main(String[] args) {
		ex04 T = new ex04();
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		M = sc.nextInt();
		arr = new int[M];
		T.DFS(0);
		sc.close();		
	}
}
/** 입출력
3 2
=>
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
*/

/** 배울점
1. 재귀를 이용한 중복순열 생성
   - DFS 함수를 통해 배열의 각 자리에 1부터 N까지의 숫자를 중복 허용하며 채워, 총 N^M 가지의 경우를 탐색함
   - 재귀의 깊이 L은 배열의 인덱스와 직접적으로 대응되므로, L이 M에 도달하면 하나의 경우가 완성됨

2. for 루프와 재귀 호출의 결합 원리
   - for (int i = 1; i <= N; i++) {
         arr[L] = i;
         DFS(L + 1);
     }
   - 현재 재귀 깊이 L에서 가능한 모든 선택(1부터 N)을 순차적으로 할당 후, DFS(L + 1)로 다음 자리 탐색
   - 재귀 호출이 끝나면 자동으로 이전 상태로 돌아가 다음 i 값을 시도하므로 별도의 백트래킹 코드가 필요 없음

3. 재귀 호출의 자연스러운 백트래킹
   - 각 DFS 호출은 함수 호출 스택에 의해 관리되며, 하나의 경로가 완료되면 스택이 해제되면서 이전 상태가 복원됨
   - 이 구조를 활용해 모든 경우의 수를 체계적으로 탐색할 수 있음
*/

/* 해설
[코드 상세 해설 및 for 루프의 심화 분석]
1. DFS 함수의 기본 흐름
   - 기저 조건: if (L == M)
       * 배열의 모든 자리가 채워지면 현재까지 저장된 배열(arr)을 출력
   - 재귀 진행: else 구문 내에서 for 루프를 통해 각 자리에 1부터 N까지의 값을 할당

2. for 루프의 역할과 원리
   - for (int i = 1; i <= N; i++) {
         arr[L] = i;
         DFS(L + 1);
     }
   - 이 루프는 '현재 위치 L'에 대하여 가능한 모든 숫자 i를 시도
     a. arr[L] = i; 
        * 현재 재귀 단계에서 배열의 L번째 인덱스에 i라는 값을 할당. 
        * 이 할당은 "현재 위치에 대한 선택"으로, 이후 재귀 호출에서 이 선택이 바탕이 됨.
     b. DFS(L + 1);
        * 현재 선택(i)을 고정한 상태에서, 다음 위치(L + 1)에 대해 재귀적으로 가능한 모든 값을 탐색.
   - 재귀 호출이 진행될 때마다 함수 호출 스택에 현재 상태가 저장되므로, DFS(L + 1)이 끝나면 자동으로 이전 상태(현재 for 루프의 상태)로 복귀함.
   - 이 과정이 반복되면서 모든 가능한 조합(중복순열)이 출력됨.

3. 재귀 호출과 백트래킹의 작동 원리
   - 각 DFS 호출은 하나의 결정(숫자 선택)을 수행하며, 결정이 완료되면 다음 재귀 호출로 넘어감.
   - 한 경로가 완성되어 출력된 후, 해당 DFS 호출은 종료되고 함수 호출 스택이 해제됨.
   - 해제된 후, for 루프는 다음 i 값을 선택하며, 새로운 재귀 경로를 시작함.
   - 이러한 과정은 DFS의 깊이 우선 탐색 특성을 그대로 반영하며, 모든 경우의 수를 빠짐없이 탐색할 수 있도록 함.

4. 전체 실행 과정 예시 (N=3, M=2)
   - DFS(0) 호출 → L=0, for 루프에서 i=1 선택 → arr[0]=1 → DFS(1) 호출
       * DFS(1): L=1, for 루프에서 i=1 선택 → arr[1]=1 → DFS(2) 호출
           - DFS(2): L==M(2)이므로 출력: "1 1"
       * DFS(1): 다음 i=2 선택 → arr[1]=2 → DFS(2) 호출 → 출력: "1 2"
       * DFS(1): 다음 i=3 선택 → arr[1]=3 → DFS(2) 호출 → 출력: "1 3"
   - DFS(0): 다음 i=2 선택 → arr[0]=2 → DFS(1) 호출 → 반복하여 "2 1", "2 2", "2 3" 출력
   - DFS(0): 다음 i=3 선택 → arr[0]=3 → DFS(1) 호출 → 반복하여 "3 1", "3 2", "3 3" 출력


5. 재귀 호출 과정 시각화 (N=3, M=2의 경우)
                   DFS(0)
              /      |      \
        arr[0]=1  arr[0]=2  arr[0]=3
          /            |           \
       DFS(1)        DFS(1)       DFS(1)
     /   |   \      /   |   \     /   |   \
 arr[1]= arr[1]= arr[1]= ... 반복 ... arr[1]=3
   1      2      3                       
   |      |      |                       |
 출력    출력    출력                    출력
 [1,1]  [1,2]  [1,3]                   [3,3]

*/
