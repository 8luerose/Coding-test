package section_08;
import java.util.*;

public class ex13 {
	static int[][] arr;
	static int N;
	static int answer = 0;
	static int nx, ny;
	static int[] dx = {-1, -1, 0, 1, 1, 1, 0, -1};
	static int[] dy = {0, 1, 1, 1, 0, -1, -1, -1};
	public void DFS(int x, int y) {
		for (int i = 0; i < 8; i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];
			if (nx >= 0 && nx < N && ny >= 0 && ny < N && arr[nx][ny] == 1) {
				arr[nx][ny] = 0;
				DFS(nx, ny);
			}
		}
	}
	public void solution() {
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				if (arr[i][j] == 1) {
					answer++;
					arr[i][j] = 0;
					DFS(i, j);
				}
			}
		}
	}
	public static void main(String[] args) {
		ex13 T = new ex13();
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		arr = new int[N][N];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				arr[i][j] = sc.nextInt();
			}
		}
		T.solution();
		System.out.println(answer);
		sc.close();
	}
}
/** 입출력
7
1 1 0 0 0 1 0
0 1 1 0 1 1 0
0 1 0 0 0 0 0
0 0 0 1 0 1 1
1 1 0 1 1 0 0
1 0 0 0 1 0 0
1 0 1 0 1 0 0
=>
5
*/

/** 배울점
1. DFS를 활용한 섬나라 아일랜드 문제 해결
   - N x N 격자판에서 1(땅)으로 표시된 영역이 상하좌우 및 대각선(8방향)으로 연결된 섬들을 찾는 문제.
   - 각 섬을 찾으면 answer를 1 증가시키고, DFS를 통해 해당 섬에 속하는 모든 1을 0으로 변경하여 재방문을 방지함.

2. 8방향 탐색의 활용
   - dx와 dy 배열은 8방향의 오프셋을 정의함.
     * dx = {-1, -1, 0, 1, 1, 1, 0, -1}
     * dy = { 0,  1, 1, 1, 0, -1, -1, -1}
   - 이 배열들을 이용해 현재 셀에서 대각선을 포함한 모든 인접 셀의 좌표 (nx, ny)를 계산할 수 있음.
   - 방향 탐색 시 인덱스 i를 활용하면 반복문 하나로 모든 방향 탐색 가능:
     * i=0: 상(↑), i=1: 상우(↗), i=2: 우(→), i=3: 우하(↘)
     * i=4: 하(↓), i=5: 하좌(↙), i=6: 좌(←), i=7: 좌상(↖)

3. arr[i][j] = 0 -> DFS() 호출하는 이유?
   - solution() 함수에서, 섬의 시작점(값 1)을 발견하면 곧바로 arr[i][j]를 0으로 변경하고 DFS를 호출.
   - 이는 해당 섬의 모든 연결된 땅을 '방문 처리'하여, 같은 섬을 중복해서 세지 않도록 하는 핵심 역할을 함.
   - ** 근데! 처음에 DFS 호출하게 되면 다음nx,ny부터 0으로 바꾸기 때문에, 첫 DFS()호출 전에 0으로 바꿔주는 것 **
*/

/* 해설
[전체 동작 원리 및 DFS의 상세 분석]

1. 전체 동작 원리
   - 격자판을 전체 순회하며, 값이 1인 셀(땅)을 만나면 새로운 섬의 시작점으로 인식.
   - 섬의 개수를 나타내는 answer를 1 증가시키고, 해당 셀과 연결된 모든 땅을 DFS를 통해 탐색하여 0으로 변경.
   - 이렇게 변경된 셀은 이후 순회에서 다시 탐색되지 않으므로, 섬의 중복 카운팅을 방지할 수 있음.

2. 8방향 탐색 (dx, dy 배열)
   - dx와 dy 배열은 다음과 같은 8가지 방향을 나타냄:
       0: 왼쪽 위, 1: 위, 2: 오른쪽 위, 3: 오른쪽, 4: 오른쪽 아래, 5: 아래, 6: 왼쪽 아래, 7: 왼쪽.
   - DFS 함수 내 for문에서, 각 방향에 대해:
         int nx = x + dx[i];
         int ny = y + dy[i];
     를 사용하여 현재 셀 (x, y)에서 이동할 인접 셀 (nx, ny)의 좌표를 계산함.
   - 이 방식은 상하좌우 뿐 아니라 대각선 방향의 연결도 모두 탐색할 수 있게 함.

3. ** 섬 1을 0으로 가라앉힌다고 생각해라 or 오염시킨다고 생각해라 **
	- 8방향 탐색해서 만약 1 만나면 0으로 '오염 or 봉우리 가라앉힌다' 라고 생각하자

4. ** 8방향 탐색 암기 **
	(-1,-1)  (-1,0)  (-1,1)
	(0,-1)   (0,0)   (0,1)
	(1,-1)   (1,0)   (1,1)
	=> 이걸 머리속으로 떠올려라 12시부터 시계방향으로!
	- 참고
		dx: -1-1 0 111 0 -1
		dy: 0 111 0 -1-1-1
*/
