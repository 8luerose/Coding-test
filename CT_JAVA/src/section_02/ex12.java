package section_02;
import java.util.*;

public class ex12 {
    public int solution(int n, int m, int[][] arr) {
        int answer = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                int cnt = 0;
                if (i == j) continue;
                for (int row = 0; row < m; row++) {
                    int tmp1 = 0, tmp2 = 0;
                    for (int col = 0; col < n; col++) {
                        if (arr[row][col] == i) tmp1 = col;
                        if (arr[row][col] == j) tmp2 = col;
                    }
                    if (tmp1 < tmp2) cnt++;
                }
                if (cnt == m) answer++;
            }
        }
        return (answer);
    }
    public static void main (String[] args) {
        ex12 T = new ex12();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] arr = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                arr[i][j] = sc.nextInt();
            }
        }
        System.out.print(T.solution(n, m, arr));
        sc.close();
    }

}

/** 입출력
4 3
3 4 1 2
4 3 2 1
3 1 4 2
=> 3
*/

/** 배울점
1. 경우의 수를 생각해라
    - '3번 학생'을 기준으로 (3,4) -> (3,1) -> (3,2) 이런 경우의 수가 나올 수 있다. 즉, 자기자신을 제외하면 4-1 = 3가지 경우의 수가 나온다.
    - 총 4번까지 있으니까 4 * 3 = 12가지 경우의 수가 나온다.

2. 등수와 학생 번호를 헷갈리지 말자
    - "3 4 1 2" == 3번 학생은 1등이고, 4번 학생은 2등이다
    - 3번 학생의 등수를 파악하고, 4번 학생의 등수를 파악해야 한다
    - 그러기 위해선 for col로 돌면서 '3번 학생의 등수'와 '4번 학생의 등수'를 파악해야 한다
    - "if (arr[line][col] == 3번학생) tmp1 = 1등", "if (arr[line][col] == 4번학생) tmp2 = 2등" 이런 식으로 등수를 구해주는 것이다

3. 학생 번호는 1번부터 4번까지 있다
    - 이 문제의 핵심은, '멘토와 멘티가 될 수 있는 경우'를 찾는 것이다. 멘토가 멘티보다 '모든 시험에서 점수가 높은 경우'를 찾는 것이다
    - 따라서 '1번 학생부터' 시작한다 (1,1) -> (1,2) -> (1,3) -> (1,4)
    - for (1~4번) - for (1~4번) 으로 [1][1,2,3,4...] 이런 식으로 2중 포문 돌려준다.
    - (단, if (1번 == 1번) 이면 등수 비교가 불가하다 -> continue)

4. ** 이 문제의 핵심은, 문제에서 주어진 "3 4 1 2"에 빠져들 게 아니라, 1번 학생의 위치를 찾고, 2번 학생의 '위치를 찾아서 등수를 비교'하는 것이다 **
    - "1번이 어딨냐.. 어.. 3번째에 있으니까 3등이네? 2번이 어딨냐... 어.. 4번째에 있으니까 4등이네?"
    - -> "일단 첫번째 시험에서는 1번이 등수 높으니까 멘토 가능하겠네! cnt++"
    - -> "(1,2)가 다음 시험(row)에서도 유지되나? ... '[row][col] == [2번째 시험에서][4등]' 어? 1번 학생은 4등이구나! ... 2번 학생은 3등이구나!"
    - -> "(1,2)는 위에서 유지됐지만, 지금은 아니네 cnt 증가하지 말아야지.."
    - -> "cnt 확인 해보자.. cnt 체크 횟수가 m번 시험과 같나? 다 통과했나? (cnt == m)" -> "통과했으면 answer++"
    
5. ** 컴퓨터 입장에서 '순서대로 처리'하면 효율적으로 한 번에 할 수 있겠다 라는 사고를 가져야 한다 **
    - "3번? 아 3번은 첫번째 시험에서.. (3) 4 1 2 네.." -> "2번째 시험에서 (3) 2 1 이네" (X) == 일일이 분산돼서 중구난방함
    - "음 1~4번까지 존재하는 구나. 순서대로 한 번에 처리하면 모든 경우를 확인할 수 있으니 효율적이겠다" (O) == 순서대로 처리해서 효율적이다
    - 이때 (1,2) -> (1,3) -> (1,4) -> 이런 식으로 찾아야 한다고 떠올랐으면, "3 4 1 2"라는 순번에서 등수를 찾아주면 된다.

= 알고리즘은 효율적이게, 중구난방으로 처리하지 않고, 순서대로 처리해야 한다. 이 과정에서 O(n^2)이 나오더라도 괜찮다. '일단 답을 구하는 것이 중요하다'
*/

/* 해설
1. 멘토가 멘티보다 등수가 높아야 한다
    - 3번 학생과 4번 학생을 기준으로 보았을 때, 첫째 케이스에서 (3, 4)는 이지만 둘째 케이스에서 (4, 3)으로 일관되게 3번이 우수하지 않음
    - m번의 시험에서 '일관되게' 우수한 경우에만 멘토가 될 자격이 존재함
    - 일관된지 확인하기 위해, 'm번의 확인 검사 필요 + 3번 학생의 등수와 4번학생의 등수가 필요'
    - m번의 검사를 for row로 두고, 각 학생의 등수를 알기 위해 for col로 둔다
    - 예를 들어 첫번째 검사에서, '3번 학생의 등수는 1등, 4번 학생의 등수는 2등'이었다.
    - 따라서, 3번 학생이 m번 검사를 받는데, 그때마다 4번 학생보다 등수가 높아야 한다.
    - 통과 횟수를 세고, 이것이 m번과 같다면 '멘토와 멘티가 될 수 있는 경우이기 때문에' answer++
*/