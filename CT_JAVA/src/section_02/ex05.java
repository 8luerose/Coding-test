package section_02;
import java.util.*;

class ex05 {
    public int solution(int n) {
        int cnt = 0;
        int [] arr = new int[n + 1];
        for (int i = 2; i < n; i++) {
            if (arr[i] == 0) {
                cnt++;
                for (int j = i; j < n; j = j + i) arr[j] = 1;
            }
        }
        return (cnt);
    }
    public static void main(String[] args) {
        ex05 T = new ex05();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.print(T.solution(n));
    }
}

/** 입출력
 * 20
 * => 8
 */

/* 해설
1. 에라토스테네스의 체란?
- 소수를 찾는 방법 중 하나로, 2부터 시작해서 2의 배수를 모두 지우고, 3의 배수를 모두 지우고, 5의 배수를 모두 지우는 방식으로 소수를 찾는 방법이다.
- 예를 들어, 2가 소수인지 판단하고, 2의 배수인 4, 6, 8, 10, 12.. 을 flag 1 처리한다
- 다음 순회 또한 동일한 방식으로 진행한다. 소수인지 판단하고, 그의 배수에 flag 1 처리.
- 처음에 flag는 0으로 초기화 되어 있다는 점을 이용해서, flag값이 0인것만 소수로 판단하고, 그의 배수에 flag 1 처리한다.
- 이렇게 하면, 점점 소수만 남게 되고, 소수의 개수를 세면 된다. -> 시간복잡도 빠르다

2. new 배열 하면, 자동으로 0으로 초기화 되는 것을 이용해서, 0인것만 소수로 판단하고, 그의 배수에 1로 체크한다.

3. 배수는 어떻게 구하지?
- j = i 이고, j = j + i로 하면, i = i + i 이므로 배수가 된다.
- 즉, 핵심은 j는 발견된 지점부터 시작돼서 'j = j + i' 로 점차 증가한다는 것

4. 예
2[0] 3[0] 4[0]..
-> 2에 도착하면, flag가 0인지 판단하고, 소수가 맞다면 개수 증가 -> 배수 체크
2[1] 3[0] 4[1] 5[0] 6[1]..
-> 3에 도착하면, flag가 0인지 판단하고, 소수가 맞다면 개수 증가 -> 배수 체크
.. 반복

5. flag 체크 및 판단을 위한 배열 갯수
- 실제 현실의 수는 1 ~ 20까지 이므로 21개가 필요하다. -> 20까지 만들면 0 ~ 19까지다
- 따라서, n + 1개가 필요하다.
 */