package section_10;
import java.util.*;

public class ex06 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int M = sc.nextInt();
		int[] dy = new int[M + 1];
		for (int i = 0; i < N; i++) {
			int score = sc.nextInt();
			int time = sc.nextInt();
			for (int j = M; j >= time; j--) {
				dy[j] = Math.max(dy[j], dy[j - time] + score);
			}
		}
		System.out.println(dy[M]);
		sc.close();
	}
}
/** 입출력
▣ 입력예제 1
5 20
10 5  // 첫 번째 값: 점수, 두 번째 값: 해결 시간
25 12
15 8
6 3
7 4

▣ 출력예제 1
41
*/

/** 배울점

1. 문제 유형 식별 -> "0/1 배낭(Knapsack) 문제"
- 이 문제가 "0/1 배낭 문제"임을 파악하는 것이 중요함.
- 판단 근거:
    -> 1. "제한된 용량"(여기서는 총 '시간 M')이 주어짐.
    -> 2. "각 아이템"(여기서는 각 '문제')을 "선택할지(1) 말지(0) 결정"해야 함 (즉, 각 문제는 최대 한 번만 풀 수 있음).
    -> 3. "가치의 총합"(여기서는 '점수')을 "최대로" 만드는 것이 목표임.
- "동전 교환 문제"와의 핵심 차이점:
    -> 동전 교환: 같은 종류의 동전을 여러 번 사용할 수 있었음 (아이템 개수 무제한 -> Unbounded Knapsack).
    -> 이 문제: 각 문제는 딱 한 번만 풀 기회가 주어짐 (아이템 개수 제한 -> 0/1 Knapsack).

2. DP 배열의 의미 정의 -> dy[j]는 무엇을 저장하는가?
- dy[j]: "정확히 j분이라는 시간을 투자했을 때, 얻을 수 있는 최대 점수"를 나타냄.
- 우리의 최종 목표는 dy[M]임. 즉, 주어진 전체 제한 시간 M분 안에서 얻을 수 있는 가장 높은 점수를 찾는 것.

3. 점화식의 논리 구조 -> dy[j] = Math.max( dy[j] (현재 'score', 'time'의 문제를 안 푸는 경우) , dy[j - time] + score (현재 'score', 'time'의 문제를 푸는 경우) )
- 특정 시간 j에서 얻을 수 있는 최대 점수(dy[j])를 어떻게 결정할까? -> 현재 바깥 루프에서 가져온 한 문제(점수: score, 시간: time)를 풀지, 말지 두 가지 선택지를 비교하여 더 유리한 쪽을 고름.

    -> 선택 1: "현재 보고 있는 문제(점수: score, 시간: time)를 풀지 않는다!"
        -> 이 경우, j분 동안 얻을 수 있는 최대 점수는 -> 이 문제를 풀지 않았으므로, 이전에 다른 문제들만으로 j분 동안 얻었던 최대 점수와 동일함. 이 값은 dy[j]에 이미 (이전 반복이나 다른 문제들을 통해) 계산되어 있을 수 있음. (만약 시간 j에 대해 이전에 어떤 문제도 풀 수 없었다면 dy[j]는 0일 것임).

    -> 선택 2: "현재 보고 있는 문제(점수: score, 시간: time)를 푼다!" (단, 현재 주어진 시간 j가 이 문제를 푸는 데 필요한 시간 'time'보다 크거나 같아야만 이 선택이 가능함)
        -> 이 문제를 푸는 데 'time' 만큼의 시간이 사용되므로, 이 문제를 풀기 전에는 나에게 (j - time) 만큼의 시간이 있었을 것임.
        -> 이 (j - time) 시간 동안, (현재 문제를 제외한) 다른 문제들을 풀어서 얻었던 최대 점수는 dy[j - time]에 이미 계산되어 저장되어 있음.
        -> 여기에 지금 푸는 문제의 점수 'score'를 더하면 -> 이것이 바로 현재 문제를 풀고 총 j분의 시간을 사용했을 때 얻는 총 점수가 됨.

- 최종적으로, dy[j]에는 위 '선택 1'과 '선택 2' 중 더 큰 점수 값이 저장됨.

4. 반복문 순회 방향: 0/1 배낭 문제의 핵심 구분점! (안쪽 for문이 왜 j=M부터 거꾸로 반복하는가?)
- 바깥 for문 (N개의 문제를 하나씩 가져와서 처리): for (int i = 0; i < N; i++) -> i번째 반복에서 한 개의 문제 정보를 가져와 변수 'score'와 'time'에 저장. 이 'score'와 'time'을 가지고 DP 테이블 업데이트 시작.
- 안쪽 for문 (DP 테이블 업데이트 - 시간을 거꾸로): for (int j = M; j >= time; j--) -> 총 제한 시간 M부터 현재 문제의 소요 시간(time)까지 시간을 역순으로 내려가면서 dy[j] 값을 계산.

- 왜 안쪽 루프에서 시간 j를 거꾸로 (M부터 time까지) 내려가면서 계산해야 하는가?
  -> 핵심 이유: "각 문제는 단 한 번만 풀 수 있다"는 0/1 배낭 문제의 규칙을 지키기 위해서!
  -> 만약 시간 j를 순서대로 (time부터 M까지 오름차순으로) 올라가면서 dy[j]를 업데이트 한다면:
     -> 현재 바깥 루프에서 가져온 한 문제 (score, time)의 정보를 사용하여 dy 배열을 업데이트하는 중임.
     -> j가 작은 값에서 큰 값으로 진행될 때, dy[j]를 계산하기 위해 dy[j - time] 값을 참조함.
     -> 이때, 만약 dy[j - time] 값이 "이미 이번 바깥 루프의 문제(score, time)를 포함해서" 업데이트된 값이라면?
        -> 예를 들어, 현재 문제 A(5시간 소요)를 보고 있을 때, j=5에서 dy[5]가 A를 포함하여 업데이트됨 (dy[5] = dy[0] + A점수).
        -> 그 후 같은 바깥 루프 내에서 j=10일 때 dy[10]을 계산하며 dy[5](즉, dy[10-5])를 참조하면, 이미 A가 포함된 dy[5]에 또 A의 점수를 더하게 되어 A를 두 번 사용한 셈이 됨. 이는 "각 문제는 한 번만" 규칙 위반.
  -> 시간 j를 거꾸로 (M부터 time까지) 내려가면서 dy[j]를 업데이트하면 이 문제가 해결됨:
     -> dy[j]를 계산할 때 참조하는 dy[j - time] 값은, 항상 "이번 바깥 루프에서 고려 중인 문제(score, time)의 정보가 아직 전혀 반영되지 않은, 즉 그 이전에 처리했던 다른 문제들만으로 계산된 최대 점수"가 됨.
     -> 예를 들어, 현재 문제(score, time)를 처리할 때, j=20에 대한 dy[20]을 먼저 업데이트함. 이때 dy[20-time]은 현재 문제가 반영되기 전의 순수한 과거 값임. 그 후 dy[20]이 업데이트됨.
     -> 다음에 j=19에 대한 dy[19]를 업데이트 할 때도, dy[19-time]은 여전히 현재 문제가 반영되기 전의 값임 (왜냐하면 j=20보다 작은 시간대의 dy 값들은 아직 이번 문제로 업데이트되지 않았으므로).
     -> 이렇게 하면, dy[j - time] + score는 현재 보고 있는 문제(score, time)를 '이번 DP 테이블 업데이트 과정에서 처음으로 사용했을 때'의 점수가 정확히 계산되어 dy 배열에 반영됨. 각 문제가 DP 테이블 업데이트 과정에서 단 한 번만 사용되는 것이 보장됨.

- 정리:
    -> 아이템(문제)을 여러 번 사용해도 된다면 (무제한 배낭, 예: 동전 교환 문제) -> 안쪽 루프는 작은 시간/무게에서 큰 값으로 (오름차순, 정순) 진행.
    -> 아이템(문제)을 딱 한 번만 사용할 수 있다면 (0/1 배낭, 예: 이 문제) -> 안쪽 루프는 큰 시간/무게에서 작은 값으로 (내림차순, 역순) 진행.

5. DP 배열의 시작 조건
- int[] dy = new int[M + 1]; -> 자바에서 int 배열은 생성 시 모든 요소가 0으로 자동 초기화됨.
- dy[0] = 0의 의미: "0분의 시간으로는 0점밖에 얻을 수 없다"는 것은 당연한 시작 조건이며, 점화식 계산의 가장 기초가 되는 값(Base Case)임.
*/

/* 해설

1. 문제 접근 방식: "한정된 시간, 문제는 한 번씩, 최대 점수는?"
-> 이 질문은 "0/1 배낭(Knapsack) 알고리즘" 문제의 특징을 나타냄.
   - "배낭" -> 우리에게 주어진 '제한 시간 M분'.
   - "물건" -> 풀어야 할 'N개의 문제들' (각 문제는 특정 점수와 해결 시간을 가짐).
   - "0/1" -> 각 문제는 '풀거나(1)' 또는 '풀지 않거나(0)' 두 가지 선택지만 가능 (한 문제를 여러 번 푸는 것은 불가능).

2. DP(동적 계획법)를 이용한 해결 과정

- DP 테이블(배열) 준비: dy[j] -> "j분"의 시간이 있을 때, 얻을 수 있는 최대 점수를 기록하는 칸.
- 최종 목표: dy[M] 값을 찾는 것. (M분 동안 가능한 최고 점수).

3. 점화식: "dy[j] 칸은 어떻게 채울까?"

- 현재, N개의 문제 중 한 문제 (점수: 'score', 해결 시간: 'time')를 보고 있음.
- 특정 시간 j (0분부터 M분까지의 어떤 시간)에 대해, 이 문제를 푸는 것이 이득인지, 안 푸는 것이 이득인지 판단.

  -> 경우 (가): "이 문제(score, time)는 이번에 안 풀겠다."
     -> 그러면, 시간 j 동안 얻을 수 있는 최대 점수는 -> 이 문제를 고려하기 전에, 다른 문제들만으로 시간 j 동안 얻었던 최대 점수와 같을 것임. (이 값은 dy[j]에 이미 계산되어 있을 수 있음).

  -> 경우 (나): "이 문제(score, time)를 풀겠다!" (단, 현재 시간 j가 이 문제를 푸는 데 필요한 'time'보다 크거나 같아야만 함)
     -> 이 문제를 푸는 데 'time'만큼의 시간이 들었으니, 이 문제를 풀기 전에는 나에게 (j - time) 만큼의 시간이 있었던 것임.
     -> 이 (j - time) 시간 동안, (현재 문제를 제외한) 다른 문제들로 얻었던 최대 점수는 dy[j - time]에 기록되어 있음.
     -> 여기에 현재 문제의 점수 'score'를 더하면 -> (dy[j - time] + score) 가 현재 문제를 풀고 총 j분의 시간을 사용했을 때 얻는 총 점수가 됨.

- dy[j]의 최종 값 결정: 위 경우 (가)와 경우 (나) 중 더 큰 점수를 주는 쪽으로 dy[j] 값을 업데이트함.
  -> dy[j] = Math.max( (경우 (가)의 점수) , (경우 (나)의 점수) ).

4. 코드 구현 핵심: 반복문의 방향 (안쪽 for문에서 시간을 왜 M부터 거꾸로 탐색하는가?)

- 바깥 for문 (N개의 각 문제를 순서대로 한 번씩 검토):
  -> for (int i = 0; i < N; i++) // 변수 'score'와 'time'에 현재 검토 중인 문제의 점수와 시간을 가져옴.

- 안쪽 for문 (DP 테이블 업데이트 - 시간 j를 큰 값에서 작은 값으로 이동하며 계산):
  -> for (int j = M; j >= time; j--) // 전체 제한 시간 M부터 현재 문제의 해결 시간(time)까지 시간을 거꾸로 내려가면서 dy[j] 값을 업데이트함.

- 왜 시간을 거꾸로 (M부터 time까지) 내려가면서 계산해야 하는가?
  -> 결정적 이유: "각 문제는 단 한 번만 풀 수 있다"는 0/1 배낭 문제의 규칙을 정확히 지키기 위해서!
  -> 만약 시간을 순서대로 (time부터 M까지) 올라가면서 dy[j]를 업데이트 한다면:
     -> 현재 바깥 루프에서 한 문제 (예: 문제 X)를 가져와 dy 배열을 업데이트 중이라고 가정.
     -> j가 작은 값에서 큰 값으로 진행될 때, dy[j]를 계산하려고 dy[j - time] 값을 보게 됨.
     -> 이때, 만약 dy[j - time] 값이 "이미 이번 문제 X를 포함해서" 업데이트된 값이라면 큰일!
        -> 예를 들어, 문제 X(5시간 소요)를 보고 있을 때, j=5에서 dy[5]가 X를 포함하여 업데이트됨.
        -> 그 후 같은 바깥 루프(여전히 문제 X를 보고 있음)에서 j=10이 되어 dy[10]을 계산하며 dy[5](즉, dy[10-5])를 참조하면, 이미 X가 포함된 dy[5]에 또 X의 점수를 더하게 되어 X를 두 번 사용한 것처럼 계산됨.

  -> 시간을 거꾸로 (M부터 time까지) 내려가면서 dy[j]를 업데이트하면 이 문제가 발생하지 않음:
     -> dy[j]를 계산할 때 참조하는 dy[j - time] 값은, 항상 "이번 바깥 루프에서 보고 있는 문제(score, time)의 정보가 아직 전혀 반영되지 않은, 즉 그 이전에 검토했던 다른 문제들만으로 계산된 최대 점수"가 됨.
     -> 예를 들어, 현재 문제(score, time)를 처리하며 j=20에 대한 dy[20]을 먼저 업데이트. 이때 dy[20-time]은 현재 문제가 반영되기 전의 값. 그 후 dy[20]이 현재 문제 정보로 업데이트됨.
     -> 다음에 j=19에 대한 dy[19]를 업데이트 할 때, dy[19-time]은 여전히 현재 문제가 반영되기 전의 값임 (왜냐하면 j=20보다 작은 시간대의 dy 값들은 아직 현재 문제 정보로 업데이트되지 않았으므로).
     -> 이렇게 하면, dy[j - time] + score는 현재 보고 있는 문제(score, time)를 '이번 DP 테이블 업데이트 싸이클에서 처음으로 사용했을 때'의 점수가 정확히 계산되어 dy 배열에 반영됨. 따라서 각 문제가 DP 테이블 업데이트 과정에서 단 한 번만 사용되는 것이 보장됨.

5. 시뮬레이션 (예제 입력: 5문제, 20분 제한 / 문제 정보: (10점,5분), (25점,12분), (15점,8분), (6점,3분), (7점,4분))
- dy 배열 (dy[0] ~ dy[20]) 모든 값이 0으로 시작.

- 첫 번째 문제 (10점, 5분) 처리:
  -> 안쪽 루프: j가 20부터 5까지 1씩 감소하며 dy 업데이트.
  -> j=20: dy[20] = max( (dy[20]의 기존값) 0, (dy[20-5]의 기존값) 0 + 10) -> dy[20]=10.
  -> j=19: dy[19] = max( (dy[19]의 기존값) 0, (dy[19-5]의 기존값) 0 + 10) -> dy[19]=10.
  ...
  -> j=5:  dy[5]  = max( (dy[5]의 기존값) 0,  (dy[5-5]의 기존값) 0 + 10) -> dy[5]=10.
  -> 이 단계 후: dy[5]부터 dy[20]까지는 모두 10으로 채워짐 (dy[0]~dy[4]는 0).

- 두 번째 문제 (25점, 12분) 처리:
  -> 안쪽 루프: j가 20부터 12까지 1씩 감소하며 dy 업데이트.
  -> j=20: dy[20] = max( (dy[20]의 현재값) 10, (dy[20-12] 즉, dy[8]의 현재값) 10 + 25) = max(10, 10 + 25) = 35.
  -> j=19: dy[19] = max( (dy[19]의 현재값) 10, (dy[19-12] 즉, dy[7]의 현재값) 10 + 25) = max(10, 10 + 25) = 35.
  ...
  -> j=17: dy[17] = max( (dy[17]의 현재값) 10, (dy[17-12] 즉, dy[5]의 현재값) 10 + 25) = max(10, 10 + 25) = 35.
  -> j=16: dy[16] = max( (dy[16]의 현재값) 10, (dy[16-12] 즉, dy[4]의 현재값) 0  + 25) = max(10, 0  + 25) = 25. (dy[4]는 첫 번째 문제 처리 시 0이었음)
  ...
  -> j=12: dy[12] = max( (dy[12]의 현재값) 10, (dy[12-12] 즉, dy[0]의 현재값) 0  + 25) = max(10, 0  + 25) = 25.
  -> dy 배열 값들이 두 번째 문제의 점수를 반영하여 업데이트됨. 예를 들어, dy[20]은 이제 35, dy[17]은 35, dy[12]는 25가 됨.

- 이러한 과정을 나머지 문제들에 대해서도 순차적으로 반복.

- 모든 문제를 다 고려한 후, dy[M] (여기서는 dy[20])에 저장된 값인 41이 이 문제의 최종 답이 됨.
*/