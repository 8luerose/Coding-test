package section_09;
import java.util.*;

public class ex06 {
	static int[] unf; // 각 학생이 속한 집합의 대표(루트) 저장 배열
	
	// Find 함수: v가 속한 집합의 대표(루트) 찾기
	public static int Find(int v) {
		if (v == unf[v]) return (unf[v]); // v가 자신의 대표(루트)인 경우 그대로 반환
		else return (unf[v] = Find(unf[v])); // 경로 압축: v의 대표를 찾아 바로 연결
	}
	
	// Union 함수: a와 b가 속한 집합을 하나로 합치기
	public static void Union(int a, int b) {
		int fa = Find(a); // a가 속한 집합의 대표
		int fb = Find(b); // b가 속한 집합의 대표
		if (fa != fb) unf[fa] = fb; // 두 집합이 다른 경우 fa를 fb 아래에 연결
	}
	
	public static void main(String[] args) {
		//static으로 Find, Union 함수 사용 위함. Main T = new Main(); 인스턴스화 불필요
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt(); // 학생 수
		int M = sc.nextInt(); // 친구 관계 수
		
		// 배열 초기화: 처음에는 각자가 자신의 집합에 속함
		unf = new int[N + 1]; // 1번부터 N번 학생까지 사용 위해 N+1 크기로 생성
		for (int i = 1; i <= N; i++) unf[i] = i; // 각 학생은 처음에 자신이 대표
		
		// 친구 관계 입력받아 처리
		for (int i = 1; i <= M; i++) {
			int a = sc.nextInt(); // 첫 번째 학생
			int b = sc.nextInt(); // 두 번째 학생
			Union(a, b); // 두 학생을 같은 친구 집합으로 합침
		}
		
		// 두 학생이 친구인지 확인
		int a = sc.nextInt(); // 확인할 첫 번째 학생
		int b = sc.nextInt(); // 확인할 두 번째 학생
		int fa = Find(a); // a의 최종 대표(루트)
		int fb = Find(b); // b의 최종 대표(루트)
		
		// 같은 대표를 가지면 같은 친구 집합에 속함 (직/간접적 친구)
		if (fa == fb) System.out.println("YES");
		else System.out.println("NO");
		
		sc.close();
	}
}
/** 입출력  
입력 예:  
9 7
1 2
2 3
3 4
1 5
6 7
7 8
8 9
3 8

출력 예:  
NO
*/

/** 배울점  
1. Disjoint-Set(서로소 집합) 자료구조의 실전 활용법  
   - unf 배열은 "각 학생의 친구 그룹 소속" 정보 저장용임
   - 예: unf[3]=4는 "3번 학생은 4번이 대표인 친구 그룹 소속" 의미임
   - 초기에는 모든 학생이 자기만의 그룹 소속이므로 unf[i]=i로 설정함

2. Find 함수의 경로 압축 최적화 기법  
   - 단순 루트 찾기: if(v!=unf[v]) return Find(unf[v])
   - 경로 압축 적용: return (unf[v] = Find(unf[v]))
   - 이 차이로 Find 연산이 거의 O(1)에 가까운 시간 복잡도 보유함
   - 예: 1→2→3→4 구조에서 Find(1) 호출 시, 1→4로 직접 연결되어 다음 호출은 O(1)임

3. Union 함수의 효율적 구현 방식  
   - 두 친구 그룹 합병 시 각 그룹의 대표(루트) 먼저 탐색함
   - 이미 같은 그룹(fa==fb)이면 합병 불필요하여 종료함
   - 다른 그룹이면 fa의 부모를 fb로 설정해 두 그룹 연결함
   - 예: {1,2,3}과 {4,5}를 합칠 때, 대표 3과 5를 찾아 unf[3]=5로 설정함

4. 배열 인덱싱 설계 방식  
   - 학생 번호가 1부터 시작이므로 unf[0]은 미사용임
   - unf 배열을 N+1 크기로 생성해 1~N 인덱스를 직관적으로 사용함
   - 이는 코드의 가독성 향상과 실수 감소를 위한 좋은 습관임

5. 친구 관계의 전이성 처리 방법  
   - 직접 친구가 아니더라도 친구의 친구는 같은 집합으로 자동 처리됨
   - 예: (1,2), (2,3) 관계가 있으면 1과 3도 같은 집합에 속하게 됨
   - 이는 Union-Find의 핵심 장점으로, 복잡한 관계를 효율적으로 표현함

6. 서로소 집합 2개 형성 이유  
   - 주어진 친구 관계가 모든 학생을 연결하지 않고 끊어진 부분이 있기 때문임
   - (1,2), (2,3), (3,4), (1,5)는 {1,2,3,4,5} 집합을 형성함
   - (6,7), (7,8), (8,9)는 {6,7,8,9} 집합을 형성함
   - 두 집합 사이에 연결 관계가 없어 서로소 집합 2개가 생성됨
*/

/* 해설  
1. 문제 상황 구체적 이해  
   - 학교에서 N명의 학생들 간 친구 관계 형성 상태임
   - 친구 관계는 직접적(A-B) 또는 간접적(A-C-D) 연결 가능함
   - 예: 1-2-3-4로 연결 시 1번과 4번도 간접적 친구 관계임
   - 문제: 특정 두 학생의 직/간접적 친구 관계 여부 판별 필요함

2. Union-Find 알고리즘 단계별 동작 과정  
   - 초기화 단계:
     → 모든 학생은 각자 자신만의 친구 그룹 소속임
     → unf[1]=1, unf[2]=2, ..., unf[9]=9로 설정됨
   
   - 친구 관계 처리 단계:
     → (1,2) 관계: Union(1,2) → unf[1]=2로 변경 (1번은 2번 그룹 소속)
     → (2,3) 관계: Union(2,3) → unf[2]=3로 변경 (2번은 3번 그룹 소속)
     → (3,4) 관계: Union(3,4) → unf[3]=4로 변경 (3번은 4번 그룹 소속)
     → 이런 식으로 진행 시 {1,2,3,4,5}와 {6,7,8,9} 두 개의 친구 그룹 형성됨
   
   - 친구 관계 확인 단계:
     → 3번과 8번의 친구 관계 확인을 위해 Find(3)와 Find(8) 호출함
     → Find(3)은 3→4로 따라가 최종적으로 4를 반환함
     → Find(8)은 8→9로 따라가 최종적으로 9를 반환함
     → 4≠9이므로 3번과 8번은 서로 다른 친구 그룹 소속임
     → 따라서 "NO" 출력함

3. 경로 압축의 실제 효과 예시  
   - 예시: 1→2→3→4 구조에서 Find(1) 호출 시
     → 처음 호출: 1→2→3→4 경로를 따라가 4를 찾음
     → 경로 압축: unf[1]=4, unf[2]=4, unf[3]=4로 모두 직접 연결됨
     → 다음 Find(1) 호출: 바로 unf[1]=4를 반환함 (O(1) 시간)
   
   - 이 최적화로 거의 상수 시간에 가까운 성능 획득 가능함

4. 예제 입력에 대한 구체적 실행 과정  
   - 초기 상태: unf = [0,1,2,3,4,5,6,7,8,9] (0번 인덱스는 미사용)
   
   - (1,2) 처리:
     → Find(1)=1, Find(2)=2
     → Union(1,2): unf[1]=2
     → unf = [0,2,2,3,4,5,6,7,8,9]
   
   - (2,3) 처리:
     → Find(2)=2, Find(3)=3
     → Union(2,3): unf[2]=3
     → unf = [0,2,3,3,4,5,6,7,8,9]
   
   - 계속 진행 시 최종적으로:
     → unf = [0,2,3,4,4,4,7,8,9,9]
     → Find(3)=4, Find(8)=9
     → 4≠9 이므로 "NO" 출력함

5. 서로소 집합 2개 형성 이유 설명  
   - 주어진 친구 관계들이 모든 학생을 하나로 연결하지 않음
   - 입력된 친구 관계를 그래프로 표현 시:
     → (1,2), (2,3), (3,4), (1,5)는 {1,2,3,4,5} 연결 컴포넌트 형성
     → (6,7), (7,8), (8,9)는 {6,7,8,9} 연결 컴포넌트 형성
   - 두 컴포넌트 사이에 연결 관계가 없어 서로소 집합 2개 생성됨
   - 이런 구조가 3번과 8번이 서로 친구가 아닌 이유임
*/
