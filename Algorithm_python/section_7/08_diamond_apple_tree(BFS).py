'''
개념

1. BFS는 동일 레벨 탐색을 의미한다
2. 해당 문제처럼 다이아몬드 방사형으로 뻗어나가는 것은 BFS로 풀어야 한다
	= 5 x 5 정사각형이 주어진다면 최초 '루트노드'를 구한다
	= 여기서 루트노드는 '중심좌표'이다 -> (n // 2, n //2)
	= 예를 들어 (2,2)가 중심좌표라면 이것을 기점으로 방사형으로 뻗어나간다
	= dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] 이렇게 4가지 방향으로 뻗어나간다
	= 보통 12 -> 3 -> 6 -> 9 '시계방향'으로 뻗어나간다
	= L = 0: (2,2) -> L = 1: (1,0), (2,3), (3,1), (2,1) 이런 식으로 진행된다
	= 계속 반복되면, 다이아몬드 형이 만들어지게 되고, 벽에 닿으면 종료된다
	= 반복

3. 문법
	= arr = [list(map(int, input().split())) for _ in range(n)]	# 2차원 배열 입력 == 한 줄씩, for _ in range(n)번
	= check = [[0] * n for _ in range(n)]						# 방문 체크 배열, [0][0][0][0][0] * for _ in range(n)
	= que.append((n // 2, n // 2))								# 튜플[0],[1]로 큐에 중심 좌표 삽입

4. *포인트*
	= dx = [-1, 0, 1, 0]	 									# 시계방향 12 -> 3 -> 6 -> 9
	= dy = [0, 1, 0, -1]										# dy는 dx의 반대
	
	= que.append((n // 2, n // 2))								# 튜플[0],[1]로 큐에 중심 좌표 삽입
	
	= que_size = len(que)										# 최초 중심좌표 (n//2,n//2)에서 4방향 뻗어나가야 하니까 하나 꺼냄
	= for i in range(que_size):									# 좌표당 4방향을 위함. 큐에 담긴 좌표 갯수 * 4
		= tmp = que.popleft()									# 큐에서 좌표 하나 꺼낸다 -> ( , ) 튜플 형식으로 .append(,)했으니까 튜플로 나온다
		
		= for j in range(4):									# 그 꺼낸 좌표를 기준으로 4방향 돌아준다
			= x = tmp[0] + dx[j]								# (,) 튜플 중 왼쪽[0] + (12 -> 3 -> 6 -> 9 좌표)
			= y = tmp[1] + dy[j]								# (,) 튜플 중 오른쪽[1] + (12 -> 3 -> 6 -> 9 좌표)
	
	= if (check[x][y] == 0):
		...
		= que.append((x , y))	

'''
from collections import deque

dx = [-1, 0, 1, 0]	 										# 시계방향 12 -> 3 -> 6 -> 9
dy = [0, 1, 0, -1]											# dy는 dx의 반대

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]	# 2차원 배열 입력 == 한 줄씩, for _ in range(n)번
check = [[0] * n for _ in range(n)]							# 방문 체크 배열, [0][0][0][0][0] * for _ in range(n)

sum = 0														# 결과용, 총합 더해야 하니까
check[n//2][n//2] = 1 										# 중심 좌표 방문 체크
sum += arr[n//2][n//2]										# 최초 좌표 -> 총합에 '더하고 시작'

#준비 됐어? 시작한다?
que = deque()												# 큐 생성
que.append((n // 2, n // 2))								# 튜플[0],[1]로 큐에 중심 좌표 삽입
L = 0														# 레벨 변경해주기 위함
while (True):
	if (L == n // 2):	 									# 최종 레벨: 사각형의 끝 부분 == 중심 좌표만큼의 거리
		break
	que_size = len(que)										# 최초 중심좌표 (n//2,n//2)에서 4방향 뻗어나가야 하니까 하나 꺼냄
	for i in range(que_size):								# 좌표당 4방향을 위함. 큐에 담긴 좌표 갯수 * 4
		tmp = que.popleft()									# 큐에서 좌표 하나 꺼낸다 -> ( , ) 튜플 형식으로 .append(,)했으니까 튜플로 나온다
		for j in range(4):									# 그 꺼낸 좌표를 기준으로 4방향 돌아준다
			x = tmp[0] + dx[j]								# (,) 튜플 중 왼쪽[0] + (12 -> 3 -> 6 -> 9 좌표)
			y = tmp[1] + dy[j]								# (,) 튜플 중 오른쪽[1] + (12 -> 3 -> 6 -> 9 좌표)
			if (check[x][y] == 0):  						# 방문한 적이 없을 때만, 총합에 더하기 위함
				sum += arr[x][y]							# 총합에 해당 좌표 넣어준다
				check[x][y] = 1								# 방문도 체크해준다
				que.append((x , y))							# 해당 좌표 방문했으니까 큐에 넣어서 BFS으로 쓴다 -> 또 가닥 뻗어야하니까 for(que_size=len(que)) - for(4방향)

	print(L, que_size)										# 테스트용, (레벨, 큐에 몇개 담겨 있는지)
	for x in check:											# 방문 좌표 -> 최대 n 줄 모두 방문할 수 있을것 == [1][1][1][1][1]
		print(x)				
	L += 1													# que에 담긴거 모두 끝나면 == i가 끝나면 -> 레벨 변경


print(sum)													# 총합 출력


'''
5
10 13 10 12 15
12 39 30 23 11
11 25 50 53 15
19 27 29 37 27
19 13 30 13 19
=
379
'''