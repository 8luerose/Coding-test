'''
개념

1. BFS는 큐를 이용한다
	= 같은 레벨들을 탐색하는 것이 BFS의 핵심이다
	= 예를 들어 0번 노드에서 1,2가 같은 1번 레벨단이면 1,2를 큐에 넣는다
	= 즉, pop의 대상을 '탐색'하면 '한번에 갈 수 있는' 가까운 레벨단의 것들을 큐에 넣어준다
	= 큐에서 루트노드 0번 pop하면 1,2 중 앞에 있는 1이 탐색된다
	= 이 1에서 한 번에 갈 수 있는 노드이자 그것과 같은 레벨단들을 큐에 넣어준다
	= 반복

2. 임의의 리스트에, 큐에 넣어놓자마자 표시를 해준다
	= 예를 들어, 5 14 라는 값이 들어왔다
	= 루트 노드는 5이고, 앞 1 뒤 1 앞 5 (3가지) 경우가 있다고 하자
	= 루트 노드에서 갈 수 있는 3가지 가닥을 뻗는다. 4 6 10
	= 이때, 4 6 10을 큐에 넣어놓자마자 표시를 해준다
	= 임의의 리스트에 5인덱스에 0을 넣어준다 *왜? 루트노드니까*
	= 4, 6, 10 인덱스에 각각 루트노드(0)에서 가는 거리 1을 더해준다
	= 만약에 4가 기준이 된다면 3가지 가닥을 뻗는다. 3 5 9
	= 3 5 9를 큐에 넣어놓자마자 표시를 해준다
	= 기준이 되는 노드였던 인덱스4의 값 1 +거리 1 = 2
	= 여기서 2는 루트노드 5에서 뻗어나가는 거리를 의미한다
	= 반복

3. 큐에 넣을 때 방문 체크를 해준다
	= 예를 들어, 루트노드 5에서 시작해서 4,6,10으로 뻗고
	= 4를 기준으로 3가닥이 또 뻗으면 3,5,9가 된다
	= 이때, 5는 이미 방문했었으니까 방문 체크 되었기 때문에 큐에 넣지 않는다

4. 루트노드에서 목적지까지의 거리가 계산된다? 바로 출력하고 스탑

+ 새로운 문법
	= for next in (now - 1, now + 1, now + 5):
	= next는 (now - 1), (now + 1), (now + 5)를 순서대로 순회
 
'''
from collections import deque						# BFS == QUE: 큐를 사용하기 위해 deque 라이브러리 사용

n, m = map(int, input().split())

MAX = 10000											# 방문 스탬프, 방문 체크 배열 만들어야 하는데, 문제에서 최대값을 10000으로 설정
check = [0] * (MAX + 1)								# 문제에서 직선의 좌표점 1부터 시작한다했으므로
district = [0] * (MAX + 1)							# 루트노드에서 목적지까지의 거리를 계산하기 위한 배열

check[n] = 1										# 루트노드 방문 체크
district[n] = 0										# 거리에도 동일하게 루트노드 값 0부터 시작

dq = deque()										# 큐 생성
dq.append(n)										# 큐에->루트노드 넣기

while (dq):											# 큐가 빌 때까지 반복
	now = dq.popleft()	  							# 큐에 담긴 것에서 pop -> 탐색
	if (now == m):									# 만약 루트노드부터 BFS로 찾은 것이, 도착지까지 도착했다면
		break

	for next in (now - 1, now + 1, now + 5):		# 큐에서 pop한 노드에서 갈 수 있는 가닥을 뻗는다
		if (0 < next <= MAX):						# 문제에서 제시한 갈 수 있는 거리 1 ~ 10000
			if (check[next] == 0):					# 방문한 적 없을 때만 queue에 넣기 위함
				dq.append(next)	 					# 큐에 넣기
				check[next] = 1						# 큐에 넣었으니까 방문했다고 방문 체크
				district[next] = district[now] + 1	# 도착지점까지의 거리 계산용 배열에 -> 현재 내 위치까지의 거리 + 1

print(district[m])									# distrcit[next]가 도착지일테니까 값이 담겼을 것. 그 도착지점의 값을 출력. 
													# (도착지까지의 거리가 담겨있음)


'''
5 14
=
3
'''