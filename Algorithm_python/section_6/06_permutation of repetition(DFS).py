'''
개념
1. 중복순열은 순열과 비슷하지만, 중복순열은 순서가 중요하지 않다.
	= 중복순열과 달리, 순열은 순서가 중요하다.
2. 중복을 허락해서 뽑아라. 라는 단순한 논리이다.
	= 3 2 라면 1~3까지 있고, 중복으로 2개를 뽑아라 라는 뜻
3. 중복순열은 DFS로 풀 수 있다.
4. 0부터 시작해서 Level은 바닥까지 증가한다
	= 예를 들어, D(L): D(L) -> D(L + 1)이고, 이 과정에서 값이 담긴다
    = 어디에? res[L]에 담긴다 res[L] = i 처럼.
    = Level 0일때 res[0]이고, 'i는 옆으로 뻗어 나간 가지의 수' (여기서는 1~3)
    = Level이 증가할 수 있는 범위까지 아래로 내려간다. (여기서는 중복 2개)
    = 즉, 1,2,3까지 뻗어나가는 경우의 수가 2회 아래로 내려간다
    = if (L == m)이면 바닥까지 내려간 것이므로 출력한다. print(res)
+ 추가 사항
	= input = sys.stdin.readline 쓰면 입력량이 많은 문자열 입력 가능
    = 그런데, 이때는 꼭 arr = input().rstrip()을 해줘야 한다
    = .rstrip()는 개행문자를 제거해준다
    = 이렇게 안하면 제대로 입력 안들어온다!
'''
def DFS(L):
    global cnt							# cnt는 main의 지역변수이므로 global로 선언
    if (L == m):
       	for j in range(m):				# 여기서 m은 레벨이자 바닥까지 가는 깊이이자, 쌓인 리스트의 갯수
            print(res[j], end = ' ')	# for 안쓰고 한번에 print(res) 하면 [0, 0] 그대로 출력된다.
        print()
        cnt += 1						# 출력한 총 갯수(일렬로 나열하는 방법)
    else:
        for i in range(1, n + 1):		# 뻗어 나가는 가지의 수. 여기서는 3이니까 1 ~ 3을 의미
            res[L] = i					# res[L]에 i를 담는다. L은 Level을 의미
            DFS(L + 1)



n, m = map(int, input().split())
res = [0] * m							# res는 중복순열을 담을 리스트. 1,2 처럼 쌓이는 총 갯수
cnt = 0									# 맨 마지막 총 경우의 수
DFS(0)
print(cnt)

'''
3 2
=
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
9
'''