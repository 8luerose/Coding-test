'''
개념
1. 방문했으면 재방문 금지 리스트에 체크= check[ ] = 1
2. DFS(1)로 시작한다 = 1번 노드부터 시작한다
3. for i in range(1, N+1) 간선 갯수만큼 DFS 가닥이 나온다
4. 그 가닥에 또 가닥이 있다면(경로가 있다면) DFS(i) 다시 재귀돈다
	= 재방문 리스트에 체크 check[ ] = 1
	= DFS 타고 레벨 내려오면 for 다시 가닥 뻗는다
	= 즉, '내려오기 전에 check[ ]=1 체크'하고 DFS(i) 가닥 뻗는다
5. if(i == N)이라면 종착지점 도착
	= 이때, cnt++
	= 할일 다했으니까 뒤로 빽
	= 이때, DFS(i) '체크 풀어주고 빽한다'
	= ex) 빽하기 전 자신의 i를 해제 D(5)종착지든, D(4)->(3)빽하기 전 D(4)든
	= check[i] = 0
	= 왜? D(2)->(5) 간선있으면 갈 수도 있기 때문에 체크 해지
6. check = [0] * (n + 1): 재방문 금지 리스트 1 ~ N까지
7. cnt = cnt + 1 해야 하는데, cnt +1 하는거니까 지역변수에서 참조하려고 한다.
	= 근데 없으니까 전역변수화 global cnt
8. 	if ((arr[v][i] == 1) and (check[i] == 0)):
	= 간선이 있고, 방문 안했다면 뜻
9. 노드 방문 전 체크 -> 방문 -> base case 도달하고 나온, DFS(i) 뒤엔 -> check[i] = 0으로 체크 풀어준다

10. 전체적인 과정
	= DFS(1)로 시작
	= 1번 노드 방문 전 check[1] = 1
	= for로 가닥 뻗는다 1 ~ N 까지
	= if(arr[v][i] == 1 and check[i] == 0): 간선이 있고, 방문 안할 경우
	= v -> i 간선타고 i 노드로 이동할 예정
	= DFS() 타기 전에 check[i] = 1 미리 체크  -> path.append(i) 미리 경로에 넣어준다
	= DFS(i)
	= DFS(i) 펑펑펑 끝나고 빽해서 옆에 for 가닥으로 이동해야 하니까 check[i] = 0  -> path.pop() 빽하기 전에 경로에서 빼준다
	= if (v == n) 끝까지 도착했다면 cnt += 1 -> for x in path 해서 그동안 쌓아놓은 경로 출력 -> 줄 바꿈
	= 펑 터지면 DFS(i) 로 돌아가겠지? 끝~ 
'''
def DFS(v):														# v = 노드 번호. 영어로 vertex
	global cnt													# cnt = 종착지점 도착 횟수
	if (v == n):												# 종착지점 도착
		cnt += 1
		for x in path:											# append 해놨던 경로 출력
			print(x, end = ' ')									# 쌓아놓은 경로 출력 ex) 1 2 5
		print()
	else:														# 종착지점 도착 못했으면
		for i in range(1, n + 1):								# '방문 가능한 노드 갯수'만큼 DFS 가닥이 나온다 1 ~ N
			if ((arr[v][i] == 1) and (check[i] == 0)):			# v->i 간선이 있고, 방문 안했다면,
				check[i] = 1									# 방문할거니까 리스트에 '미리' 방문했다고 체크
				path.append(i)									# v->i 로 갈거니까 '미리' 넣어준다
				DFS(i)											# 해당 노드로 방문 (간선 있었기 때문에 가능)
				path.pop()										# 뒤로 빽할거니까 경로 리스트에서 i를 빼준다
				check[i] = 0									# 위에서 방문하고 나온 상태. 뒤로 빼야되는데, 빽하기 전 자신의 i를 해제하고 for로 뻗은 옆에 가닥으로 간다



n, m = map(int, input().split())
arr = [[0] * (n + 1) for _ in range(n + 1)]						# 인접행렬. n+1인 이유는 1~N까지. 인덱스 0은 비워둔다
check = [0] * (n + 1)											# 재방문 금지 리스트. n+1인 이유는 1~N까지. 인덱스 0은 비워둔다
for i in range(1, m + 1):										# m번의 걸쳐 '주어진'간선 정보(연결 정보)를 입력받는다
	a, b = map(int, input().split())
	arr[a][b] = 1												# 인접행렬 만들기. a -> b 간선이 있다면 1로 체크

cnt = 0
path = []														# 경로 저장 리스트 1 2 5, 1 3 4 2 5 이런 식. 경로 출력 위함
path.append(1)													# 경로 1번 노드부터 시작하니까 미리 1번을 넣어준다
check[1] = 1													# 1번 노드부터 시작하니까 미리 1번을 1로 만들어준다
DFS(1)															# 1번 노드부터 시작
print(cnt)



'''
5 9
1 2
1 3
1 4
2 1
2 3
2 5
3 4
4 2
4 5
=
6
'''