'''
개념
1. 중복 순열 문제와 거의 같다
	= '순열'은 중복 불가
	= 체크리스트를 사용해서 중복을 방지한다
2. check 리스트를 사용해서 중복을 방지한다
	= check = [0] * (n + 1) 만드는데, 0번째 인덱스는 사용하지 않고 실제 사용하는 인덱스는 1부터 시작한다
	= check[i] = 1 이면 i번째 인덱스를 사용했다는 의미
	= 예를 들어, 1,2,3 동전 중 1을 사용했다면 check['1'] = 1 이렇게 체크
	= check [0][1][0][0] 이런 식
3. D(L)에서 L은 레벨을 의미한다. 깊게 파고 들어가는 Level정도
	= D(1) 딱 닿으면 값을 result리스트에 담는다 
	= 1,2,3 중 1을 사용했다면, D(1)에서 1을 사용했다는 의미로 result[1] = 1
	= 계속 파고 들어가면 D(1) -> D(2) .. 이런 식
	= 근데, 문제에선 M개를 뽑느다고 헀으므로 result는 [][] 이렇게 두 개
4. 순열 문제이므로 중복이 불가하다. 즉 check리스트를 확인해서 사용된 값이면 파고 들어가지 않는다
	= check[i] == 1 이면 사용했다는 의미, check[i] == 0 이면 사용하지 않았다는 의미
	= 출력하고, 그 부분 끝나서 back을 하면 check[i] = 0으로 다시 초기화
	= 예를 들어 1 끝나면 check 리스트에서 해제. check[1] = 0
'''
def DFS(L):
	global cnt								#cnt는 main에서 선언됐으므로 global로 선언
	if (L == m):
		for j in range(L):					#그동안 result에 담긴 값 출력
			print(result[j], end = ' ')		#result에 담긴 값 출력
		print()
		cnt = cnt + 1						#M개를 뽑았으므로 cnt + 1
	else:
		for i in range (1, n + 1):			#check에 없는거 찾고, 기록해가면서 DFS. ex) 1,2,3을 돈다
			if (check[i] == 0):				#해당 값 사용하지 않았다는 의미
				check[i] = 1				#사용했다고 기록
				result[L] = i				#해당 깊이 위치에 사용된 값을 담음-> m깊이만큼 담을 수 있고 꽉 차면 출력
				DFS(L + 1)					#다음 레벨
				check[i] = 0				#D(L)해당 레벨 끝나고 돌아오면, check[i] = 1 아직 이 상태인것. 이제 다시 사용하지 않았다고 기록




n, m = map(int, input().split())
result = [0] * n
check = [0] * (n + 1)
cnt = 0
DFS(0)
print(cnt)



'''
3 2
=
1 2
1 3
2 1
2 3
3 1
3 2
6
'''